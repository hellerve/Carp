(load "Vector.carp")

(deftype (Mat33 a) [
  xx a, xy a, xz a,
  yx a, yy a, yz a,
  zx a, zy a, zz a,
])

(defmodule Mat33
  (doc zero "is a generic `zero` function of a `Mat33`. It will call `zero` on
all its members, i.e. `zero` must be defined on them.")
  (defn zero []
    (init (zero) (zero) (zero) (zero) (zero) (zero) (zero) (zero) (zero)))

  (doc create-scale "creates a matrix that scales by a constant factor `k`.")
  (defn create-scale [k]
    (init k (zero) (zero) (zero) k (zero) (zero) (zero) k))

  (todo create-translate "How to push generic 1 in there?")
  (doc create-translate "creates a matrix that translates a Vector2 by `x` and
`y`.")
  (defn create-translate [x y]
    (init 1.0 (zero) (zero) (zero) 1.0 (zero) x y 1.0))

  (todo create-rotate "Should we have a generic implementation of `sin` and `cos`?")
  (doc create-rotate "creates a matrix that rotates a Vector2 by `theta?.")
  (defn create-rotate [theta]
    (let [st (Double.sin theta)
          ct (Double.cos theta)]
      (init ct st 0.0 (neg st) ct 0.0 0.0 0.0 1.0)))

  (todo ident "How to push generic 1 in there?")
  (doc ident "returns the identity matrix.")
  (defn ident []
    (create-scale 1.0))

  (todo inverse "How to push generic 1 in there?")
  (doc inverse "calculates the inverse matrix to `m`. If the determinant of
the matrix is `0.0`, `Maybe.Nothing` will be returned.")
  (defn inverse [m]
    (let [xx @(xx m)
          xy @(xy m)
          xz @(xz m)
          yx @(yx m)
          yy @(yy m)
          yz @(yz m)
          zx @(zx m)
          zy @(zy m)
          zz @(zz m)
          vxx (- (* yy zz) (* yz zy))
          vxy (- (* xz zy) (* xy zz))
          vxz (- (* xy yz) (* xz yy))
          vyx (- (* yz zx) (* yx zz))
          vyy (- (* xx zz) (* xz zx))
          vyz (- (* xz yx) (* xx yz))
          vzx (- (* yx zy) (* yy zx))
          vzy (- (* xy zx) (* xx zy))
          vzz (- (* xx yy) (* xy yx))
          fdet (+ (* xx vxx) (+ (* xy vyx) (* xz vzx)))]
      (if (= fdet (zero))
        (Maybe.Nothing)
        (let [finvdet (/ 1.0 fdet)]
          (Maybe.Just
            (Mat33.init
              (* finvdet vxx) (* finvdet vxy) (* finvdet vxz)
              (* finvdet vyx) (* finvdet vyy) (* finvdet vyz)
              (* finvdet vzx) (* finvdet vzy) (* finvdet vzz)))))))

  (doc add "adds two matrices.")
  (defn add [a b]
    (init
      (+ @(xx a) @(xx b)) (+ @(xy a) @(xy b)) (+ @(xz a) @(xz b))
      (+ @(yx a) @(yx b)) (+ @(yy a) @(yy b)) (+ @(yz a) @(yz b))
      (+ @(zx a) @(zx b)) (+ @(zy a) @(zy b)) (+ @(zz a) @(zz b))))

  (doc sub "subtracts two matrices.")
  (defn sub [a b]
    (init
      (- @(xx a) @(xx b)) (- @(xy a) @(xy b)) (- @(xz a) @(xz b))
      (- @(yx a) @(yx b)) (- @(yy a) @(yy b)) (- @(yz a) @(yz b))
      (- @(zx a) @(zx b)) (- @(zy a) @(zy b)) (- @(zz a) @(zz b))))

  (doc map "maps all elements in a matric `m` to a function `f`.")
  (defn map [m f]
    (init
      (f @(xx m)) (f @(xy m)) (f @(xz m))
      (f @(yx m)) (f @(yy m)) (f @(yz m))
      (f @(zx m)) (f @(zy m)) (f @(zz m))))

  (doc mul "multiplies two matrices.")
  (defn mul [a b]
    (init
      (* @(xx a) @(xx b)) (* @(xy a) @(xy b)) (* @(xz a) @(xz b))
      (* @(yx a) @(yx b)) (* @(yy a) @(yy b)) (* @(yz a) @(yz b))
      (* @(zx a) @(zx b)) (* @(zy a) @(zy b)) (* @(zz a) @(zz b))))

  (doc multrans "multiplies two matrices<sup>T</sup>.")
  (defn multrans [a b]
    (init
      (+ (* @(xx a) @(xx b)) (+ (* @(xy a) @(yx b)) (* @(xz a) @(zx b))))
      (+ (* @(xx a) @(xy b)) (+ (* @(xy a) @(yy b)) (* @(xz a) @(zy b))))
      (+ (* @(xx a) @(xz b)) (+ (* @(xy a) @(yz b)) (* @(xz a) @(zz b))))
      (+ (* @(yx a) @(xx b)) (+ (* @(yy a) @(yx b)) (* @(yz a) @(zx b))))
      (+ (* @(yx a) @(xy b)) (+ (* @(yy a) @(yy b)) (* @(yz a) @(zy b))))
      (+ (* @(yx a) @(xz b)) (+ (* @(yy a) @(yz b)) (* @(yz a) @(zz b))))
      (+ (* @(zx a) @(xx b)) (+ (* @(zy a) @(yx b)) (* @(zz a) @(zx b))))
      (+ (* @(zx a) @(xy b)) (+ (* @(zy a) @(yy b)) (* @(zz a) @(zy b))))
      (+ (* @(zx a) @(xz b)) (+ (* @(zy a) @(yz b)) (* @(zz a) @(zz b))))))

  (doc scale "scales a matrix `m` by a constant factor `k`, element-wise.")
  (defn scale [m k]
    (init
      (* @(xx m) k) (* @(xy m) k) (* @(xz m) k)
      (* @(yx m) k) (* @(yy m) k) (* @(yz m) k)
      (* @(zx m) k) (* @(zy m) k) (* @(zz m) k)))

  (doc col "gets a column—as a `Vector3`—from a matrix `m` by index. Valid
values are `0` to `2`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn col [m i]
    (case i
      0 (Maybe.Just (Vector3.init @(xx m) @(yx m) @(zx m)))
      1 (Maybe.Just (Vector3.init @(xy m) @(yy m) @(zy m)))
      2 (Maybe.Just (Vector3.init @(xz m) @(yz m) @(zz m)))
      (Maybe.Nothing)))

  (doc row "gets a row—as a `Vector3`—from a matrix `m` by index. Valid values
are `0` to `2`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn row [m i]
    (case i
      0 (Maybe.Just (Vector3.init @(xx m) @(xy m) @(xz m)))
      1 (Maybe.Just (Vector3.init @(yx m) @(yy m) @(yz m)))
      2 (Maybe.Just (Vector3.init @(zx m) @(zy m) @(zz m)))
      (Maybe.Nothing)))

  (doc diag "gets the diagonal of a matrix `m` as a `Vector3`.")
  (defn diag [m]
    (Vector3.init @(xx m) @(yy m) @(zz m)))

  (doc nth "gets an element in the matrix `m` by the row and column indices `i`
and `j`. Valid values are `0` to `2` for each.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn nth [m i j]
    (case (+ (* 3 i) j)
      0 (Maybe.Just @(xx m))
      1 (Maybe.Just @(xy m))
      2 (Maybe.Just @(xz m))
      3 (Maybe.Just @(yx m))
      4 (Maybe.Just @(yy m))
      5 (Maybe.Just @(yz m))
      6 (Maybe.Just @(zx m))
      7 (Maybe.Just @(zy m))
      8 (Maybe.Just @(zz m))
      (Maybe.Nothing)))

  (doc apply "applies a transformation matrix `m` to a `Vector3` `v`.")
  (defn apply [m v]
    (let [x @(Vector3.x v)
          y @(Vector3.y v)
          z @(Vector3.z v)]
      (Vector3.init
        (+ (* @(xx m) x) (+ (* @(xy m) y) (* @(xz m) z)))
        (+ (* @(yx m) x) (+ (* @(yy m) y) (* @(yz m) z)))
        (+ (* @(zx m) x) (+ (* @(zy m) y) (* @(zz m) z))))))

  (doc apply-left "applies a transformation matrix `m` to a `Vector3` `v`,
applied on the left.")
  (defn apply-left [m v]
    (let [x @(Vector3.x v)
          y @(Vector3.y v)
          z @(Vector3.z v)]
      (Vector3.init
        (+ (* @(xx m) x) (+ (* @(yx m) y) (* @(zx m) z)))
        (+ (* @(xy m) x) (+ (* @(yy m) y) (* @(zy m) z)))
        (+ (* @(xz m) x) (+ (* @(yz m) y) (* @(zz m) z))))))

  (doc transform-point "transforms a `Vector2` representing a point by a matrix
`m`.")
  (defn transform-point [m v]
    (let [x @(Vector2.x v)
          y @(Vector2.y v)]
      (Vector2.init
        (+ (* @(xx m) x) (+ (* @(yx m) y) @(zx m)))
        (+ (* @(xy m) x) (+ (* @(yy m) y) @(zy m))))))

  (doc = "checks for matrix equality (by checking all members).")
  (defn = [a b]
    (and*
      (= (xx a) (xx b)) (= (xy a) (xy b)) (= (xz a) (xz b))
      (= (yx a) (yx b)) (= (yy a) (yy b)) (= (yz a) (yz b))
      (= (zx a) (zx b)) (= (zy a) (zy b)) (= (zz a) (zz b))))
)

(deftype (Mat44 a) [
  ww a, wx a, wy a, wz a,
  xw a, xx a, xy a, xz a,
  yw a, yx a, yy a, yz a,
  zw a, zx a, zy a, zz a,
])

(defmodule Mat44
  (doc zero "is a generic `zero` function of a `Mat44`. It will call `zero` on
all its members, i.e. `zero` must be defined on them.")
  (defn zero []
    (init (zero) (zero) (zero) (zero)
          (zero) (zero) (zero) (zero)
          (zero) (zero) (zero) (zero)
          (zero) (zero) (zero) (zero)))

  (doc create-scale "creates a matrix that scales by a constant factor `k`.")
  (defn create-scale [k]
    (init
      k (zero) (zero) (zero)
      (zero) k (zero) (zero)
      (zero) (zero) k (zero)
      (zero) (zero) (zero) k))

  (todo ident "How to get generic 1 in there?")
  (doc ident "returns the identity matrix.")
  (defn ident []
    (create-scale 1.0))

  (todo inverse "How to push generic 1 in there?")
  (doc inverse "calculates the inverse matrix to `m`. If the determinant of
the matrix is `0.0`, `Maybe.Nothing` will be returned.")
  (defn inverse [m]
    (let [ww @(ww m) wx @(wx m) wy @(wy m) wz @(wz m)
          xw @(xw m) xx @(xx m) xy @(xy m) xz @(xz m)
          yw @(yw m) yx @(yx m) yy @(yy m) yz @(yz m)
          zw @(zw m) zx @(zx m) zy @(zy m) zz @(zz m)

          v0 (- (* yw zx) (* yx zw))
          v1 (- (* yw zy) (* yy zw))
          v2 (- (* yw zz) (* yz zw))
          v3 (- (* yx zy) (* yy zx))
          v4 (- (* yx zz) (* yz zx))
          v5 (- (* yy zz) (* yz zy))

          t0      (+ (- (* v5 xx) (* v4 xy)) (* v3 xz))
          t1 (neg (+ (- (* v5 xw) (* v2 xy)) (* v1 xz)))
          t2      (+ (- (* v4 xw) (* v2 xx)) (* v0 xz))
          t3 (neg (+ (- (* v3 xw) (* v1 xx)) (* v0 xy)))

          fdet (+ (* t0 ww) (+ (* t1 wx) (+ (* t2 wy) (* t3 wz))))
         ]
      (if (= fdet (zero))
        (Maybe.Nothing)
        (let [finvdet (/ 1.0 fdet)
              dww (* t0 finvdet)
              dxw (* t1 finvdet)
              dyw (* t2 finvdet)
              dzw (* t3 finvdet)

              dwx (neg (* finvdet (+ (- (* v5 xy) (* v4 xy)) (* v3 xz))))
              dxx      (* finvdet (+ (- (* v5 xx) (* v2 xy)) (* v1 xz)))
              dyx (neg (* finvdet (+ (- (* v4 xx) (* v2 xy)) (* v0 xz))))
              dzx      (* finvdet (+ (- (* v3 xx) (* v1 xy)) (* v0 xy)))

              v0 (- (* xw zx) (* xx zw))
              v1 (- (* xw zy) (* xy zw))
              v2 (- (* xw zz) (* xz zw))
              v3 (- (* xx zy) (* xy zx))
              v4 (- (* xx zz) (* xz zx))
              v5 (- (* xy zz) (* xz zy))

              dwy      (* finvdet (+ (- (* v5 xy) (* v4 xy)) (* v3 xz)))
              dxy (neg (* finvdet (+ (- (* v5 xx) (* v2 xy)) (* v1 xz))))
              dyy      (* finvdet (+ (- (* v4 xx) (* v2 xy)) (* v0 xz)))
              dzy (neg (* finvdet (+ (- (* v3 xx) (* v1 xy)) (* v0 xy))))

              v0- (- (* yw zx) (* yx zw))
              v1- (- (* yw zy) (* yy zw))
              v2- (- (* yw zz) (* yz zw))
              v3- (- (* yx zy) (* yy zx))
              v4- (- (* yx zz) (* yz zx))
              v5- (- (* yy zz) (* yz zy))

              dwz (neg (* finvdet (+ (- (* v5- xy) (* v4- xy)) (* v3- xz))))
              dxz      (* finvdet (+ (- (* v5- xx) (* v2- xy)) (* v1- xz)))
              dyz (neg (* finvdet (+ (- (* v4- xx) (* v2- xy)) (* v0- xz))))
              dzz      (* finvdet (+ (- (* v3- xx) (* v1- xy)) (* v0- xy)))
             ]
          (Maybe.Just
            (init
              dww dwx dwy dwz
              dxw dxx dxy dxz
              dyw dyx dyy dyz
              dzw dzx dzy dzz))))))


  (doc add "adds two matrices.")
  (defn add [a b]
    (init
      (+ @(ww a) @(ww b)) (+ @(wx a) @(wx b)) (+ @(wy a) @(wy b)) (+ @(wz a) @(xz b))
      (+ @(xw a) @(xw b)) (+ @(xx a) @(xx b)) (+ @(xy a) @(xy b)) (+ @(xz a) @(xz b))
      (+ @(yw a) @(yw b)) (+ @(yx a) @(yx b)) (+ @(yy a) @(yy b)) (+ @(yz a) @(yz b))
      (+ @(zw a) @(zw b)) (+ @(zx a) @(zx b)) (+ @(zy a) @(zy b)) (+ @(zz a) @(zz b))))

  (doc sub "subtracts two matrices.")
  (defn sub [a b]
    (init
      (- @(ww a) @(ww b)) (- @(wx a) @(wx b)) (- @(wy a) @(wy b)) (- @(wz a) @(xz b))
      (- @(xw a) @(xw b)) (- @(xx a) @(xx b)) (- @(xy a) @(xy b)) (- @(xz a) @(xz b))
      (- @(yw a) @(yw b)) (- @(yx a) @(yx b)) (- @(yy a) @(yy b)) (- @(yz a) @(yz b))
      (- @(zw a) @(zw b)) (- @(zx a) @(zx b)) (- @(zy a) @(zy b)) (- @(zz a) @(zz b))))

  (doc mul "multiplies two matrices.")
  (defn mul [a b]
    (init
      (* @(ww a) @(ww b)) (* @(wx a) @(wx b)) (* @(wy a) @(wy b)) (* @(wz a) @(xz b))
      (* @(xw a) @(xw b)) (* @(xx a) @(xx b)) (* @(xy a) @(xy b)) (* @(xz a) @(xz b))
      (* @(yw a) @(yw b)) (* @(yx a) @(yx b)) (* @(yy a) @(yy b)) (* @(yz a) @(yz b))
      (* @(zw a) @(zw b)) (* @(zx a) @(zx b)) (* @(zy a) @(zy b)) (* @(zz a) @(zz b))))

  (doc multrans "multiplies two matrices<sup>T</sup>.")
  (defn multrans [a b]
    (let [aww @(ww a) bww @(ww b) awx @(wx a) bwx @(wx b)
          awy @(wy a) bwy @(wy b) awz @(wz a) bwz @(wz b)
          axw @(xw a) bxw @(xw b) axx @(xx a) bxx @(xx b)
          axy @(xy a) bxy @(xy b) axz @(xz a) bxz @(xz b)
          ayw @(yw a) byw @(yw b) ayx @(yx a) byx @(yx b)
          ayy @(yy a) byy @(yy b) ayz @(yz a) byz @(yz b)
          azw @(zw a) bzw @(zw b) azx @(zx a) bzx @(zx b)
          azy @(zy a) bzy @(zy b) azz @(zz a) bzz @(zz b)
         ]
    (init
      (+ (* aww bww) (+ (* awx bxw) (+ (* awy byw) (* awz bzw))))
      (+ (* aww bwx) (+ (* awx bxx) (+ (* awy byx) (* awz bzx))))
      (+ (* aww bwy) (+ (* awx bxy) (+ (* awy byy) (* awz bzy))))
      (+ (* aww bwz) (+ (* awx bxz) (+ (* awy byz) (* awz bzz))))
      (+ (* axw bww) (+ (* axx bxw) (+ (* axy byw) (* axz bzw))))
      (+ (* axw bwx) (+ (* axx bxx) (+ (* axy byx) (* axz bzx))))
      (+ (* axw bwy) (+ (* axx bxy) (+ (* axy byy) (* axz bzy))))
      (+ (* axw bwz) (+ (* axx bxz) (+ (* axy byz) (* axz bzz))))
      (+ (* ayw bww) (+ (* ayx bxw) (+ (* ayy byw) (* ayz bzw))))
      (+ (* ayw bwx) (+ (* ayx bxx) (+ (* ayy byx) (* ayz bzx))))
      (+ (* ayw bwy) (+ (* ayx bxy) (+ (* ayy byy) (* ayz bzy))))
      (+ (* ayw bwz) (+ (* ayx bxz) (+ (* ayy byz) (* ayz bzz))))
      (+ (* azw bww) (+ (* azx bxw) (+ (* azy byw) (* azz bzw))))
      (+ (* azw bwx) (+ (* azx bxx) (+ (* azy byx) (* azz bzx))))
      (+ (* azw bwy) (+ (* azx bxy) (+ (* azy byy) (* azz bzy))))
      (+ (* azw bwz) (+ (* azx bxz) (+ (* azy byz) (* azz bzz)))))))

  (doc col "gets a column—as a `(VectorN 4)`—from a matrix `m` by index. Valid
values are `0` to `3`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn col [m i]
    (case i
      0 (Maybe.Just (VectorN.init 4 [@(ww m) @(xw m) @(yw m) @(zw m)]))
      1 (Maybe.Just (VectorN.init 4 [@(wx m) @(xx m) @(yx m) @(zx m)]))
      2 (Maybe.Just (VectorN.init 4 [@(wy m) @(xy m) @(yy m) @(zy m)]))
      3 (Maybe.Just (VectorN.init 4 [@(wz m) @(xz m) @(yz m) @(zz m)]))
      (Maybe.Nothing)))

  (doc row "gets a row—as a `(VectorN 4)`—from a matrix `m` by index. Valid
values are `0` to `3`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn row [m i]
    (case i
      0 (Maybe.Just (VectorN.init 4 [@(ww m) @(wx m) @(wy m) @(wz m)]))
      1 (Maybe.Just (VectorN.init 4 [@(xw m) @(xx m) @(xy m) @(xz m)]))
      2 (Maybe.Just (VectorN.init 4 [@(yw m) @(yx m) @(yy m) @(yz m)]))
      3 (Maybe.Just (VectorN.init 4 [@(zw m) @(zx m) @(zy m) @(zz m)]))
      (Maybe.Nothing)))

  (doc diag "gets the diagonal of a matrix `m` as a `(VectorN 4)`.")
  (defn diag [m]
    (VectorN.init 4 [@(ww m) @(xx m) @(yy m) @(zz m)]))

  (doc map "maps all elements in a matric `m` to a function `f`.")
  (defn map [m f]
    (init
      (f @(ww m)) (f @(wx m)) (f @(wy m)) (f @(wz m))
      (f @(xw m)) (f @(xx m)) (f @(xy m)) (f @(xz m))
      (f @(yw m)) (f @(yx m)) (f @(yy m)) (f @(yz m))
      (f @(zw m)) (f @(zx m)) (f @(zy m)) (f @(zz m))))

  (doc nth "gets an element in the matrix `m` by the row and column indices `i`
and `j`. Valid values are `0` to `3` for each.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn nth [m i j]
    (case (+ (* 4 i) j)
      0  (Maybe.Just @(ww m))
      1  (Maybe.Just @(wx m))
      2  (Maybe.Just @(wy m))
      3  (Maybe.Just @(wz m))
      4  (Maybe.Just @(xw m))
      5  (Maybe.Just @(xx m))
      6  (Maybe.Just @(xy m))
      7  (Maybe.Just @(xz m))
      8  (Maybe.Just @(yw m))
      9  (Maybe.Just @(yx m))
      10 (Maybe.Just @(yy m))
      11 (Maybe.Just @(yz m))
      12 (Maybe.Just @(zw m))
      13 (Maybe.Just @(zx m))
      14 (Maybe.Just @(zy m))
      15 (Maybe.Just @(zz m))
      (Maybe.Nothing)))

  (doc apply "applies a transformation matrix `m` to a `(VectorN 4)` `v`. If a
vector of wrong dimensionality is passed, this function returns a
`Result.Error`.")
  (defn apply [m v]
    (if (/= @(VectorN.n v) 4)
      (Result.Error
        (fmt "Mat44.apply expected a vector of dimension 4, but got %d"
             (VectorN.n v)))
      (let [w @(VectorN.nth-unsafe v 0)
            x @(VectorN.nth-unsafe v 1)
            y @(VectorN.nth-unsafe v 2)
            z @(VectorN.nth-unsafe v 3)]
        (Result.Success
          (VectorN.init 4 [
            (+ (* @(ww m) x) (+ (* @(xw m) y) (+ (* @(yw m) z) (* @(zw m) w))))
            (+ (* @(wx m) x) (+ (* @(xx m) y) (+ (* @(yx m) z) (* @(zx m) w))))
            (+ (* @(wy m) x) (+ (* @(xy m) y) (+ (* @(yy m) z) (* @(zy m) w))))
            (+ (* @(wz m) x) (+ (* @(xz m) y) (+ (* @(yz m) z) (* @(zz m) w))))
          ])))))

  (doc apply-left "applies a transformation matrix `m` to a `(VectorN 4)` `v`,
applied to the left. If a vector of wrong dimensionality is passed, this
function returns a `Result.Error`.")
  (defn apply-left [m v]
    (if (/= @(VectorN.n v) 4)
      (Result.Error
        (fmt "Mat44.apply expected a vector of dimension 4, but got %d"
             (VectorN.n v)))
      (let [w @(VectorN.nth-unsafe v 0)
            x @(VectorN.nth-unsafe v 1)
            y @(VectorN.nth-unsafe v 2)
            z @(VectorN.nth-unsafe v 3)]
        (Result.Success
          (VectorN.init 4 [
            (+ (* @(ww m) x) (+ (* @(wx m) y) (+ (* @(wy m) z) (* @(wz m) w))))
            (+ (* @(xw m) x) (+ (* @(xx m) y) (+ (* @(xy m) z) (* @(xz m) w))))
            (+ (* @(yw m) x) (+ (* @(yx m) y) (+ (* @(yy m) z) (* @(yz m) w))))
            (+ (* @(zw m) x) (+ (* @(zx m) y) (+ (* @(zy m) z) (* @(zz m) w))))
          ])))))

  (doc = "checks for matrix equality (by checking all members).")
  (defn = [a b]
    (and*
      (= (ww a) (ww b)) (= (wx a) (wx b)) (= (wy a) (wy b)) (= (wz a) (wz b))
      (= (xw a) (xw b)) (= (xx a) (xx b)) (= (xy a) (xy b)) (= (xz a) (xz b))
      (= (yw a) (yw b)) (= (yx a) (yx b)) (= (yy a) (yy b)) (= (yz a) (yz b))
      (= (zw a) (zw b)) (= (zx a) (zx b)) (= (zy a) (zy b)) (= (zz a) (zz b))))
)
