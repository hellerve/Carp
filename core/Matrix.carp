(load "Vector.carp")

(deftype (Mat33 a) [
  xx a, xy a, xz a,
  yx a, yy a, yz a,
  zx a, zy a, zz a,
])

(defmodule Mat33
  (doc zero "is a generic `zero` function of a `Mat33`. It will call `zero` on all
its members, i.e. `zero` must be defined on them.")
  (defn zero []
    (init (zero) (zero) (zero) (zero) (zero) (zero) (zero) (zero) (zero)))

  (doc create-scale "creates a matrix that scales by a constant factor `k`.")
  (defn create-scale [k]
    (init k (zero) (zero) (zero) k (zero) (zero) (zero) k))

  (todo create-translate "How to push generic 1 in there?")
  (doc create-translate "creates a matrix that translates a Vector2 by `x` and
`y`.")
  (defn create-translate [x y]
    (init 1.0 (zero) (zero) (zero) 1.0 (zero) x y 1.0))

  (todo create-rotate "Should we have a generic implementation of `sin` and `cos`?")
  (doc create-rotate "creates a matrix that rotates a Vector2 by `theta?.")
  (defn create-rotate [theta]
    (let [st (Double.sin theta)
          ct (Double.cos theta)]
      (init ct st 0.0 (neg st) ct 0.0 0.0 0.0 1.0)))

  (todo ident "How to push generic 1 in there?")
  (doc ident "returns the identity matrix.")
  (defn ident []
    (create-scale 1.0))

  (todo inverse "How to push generic 1 in there?")
  (doc inverse "calculates the inverse matrix to `m`. If the determinant of
the matrix is `0.0`, `Maybe.Nothing` will be returned.")
  (defn inverse [m]
    (let [xx @(xx m)
          xy @(xy m)
          xz @(xz m)
          yx @(yx m)
          yy @(yy m)
          yz @(yz m)
          zx @(zx m)
          zy @(zy m)
          zz @(zz m)
          vxx (- (* yy zz) (* yz zy))
          vxy (- (* xz zy) (* xy zz))
          vxz (- (* xy yz) (* xz yy))
          vyx (- (* yz zx) (* yx zz))
          vyy (- (* xx zz) (* xz zx))
          vyz (- (* xz yx) (* xx yz))
          vzx (- (* yx zy) (* yy zx))
          vzy (- (* xy zx) (* xx zy))
          vzz (- (* xx yy) (* xy yx))
          fdet (+ (* xx vxx) (+ (* xy vyx) (* xz vzx)))]
      (if (= fdet (zero))
        (Maybe.Nothing)
        (let [finvdet (/ 1.0 fdet)]
          (Maybe.Just
            (Mat33.init
              (* finvdet vxx) (* finvdet vxy) (* finvdet vxz)
              (* finvdet vyx) (* finvdet vyy) (* finvdet vyz)
              (* finvdet vzx) (* finvdet vzy) (* finvdet vzz)))))))

  (doc add "adds two matrices.")
  (defn add [a b]
    (init
      (+ @(xx a) @(xx b)) (+ @(xy a) @(xy b)) (+ @(xz a) @(xz b))
      (+ @(yx a) @(yx b)) (+ @(yy a) @(yy b)) (+ @(yz a) @(yz b))
      (+ @(zx a) @(zx b)) (+ @(zy a) @(zy b)) (+ @(zz a) @(zz b))))

  (doc sub "subtracts two matrices.")
  (defn sub [a b]
    (init
      (- @(xx a) @(xx b)) (- @(xy a) @(xy b)) (- @(xz a) @(xz b))
      (- @(yx a) @(yx b)) (- @(yy a) @(yy b)) (- @(yz a) @(yz b))
      (- @(zx a) @(zx b)) (- @(zy a) @(zy b)) (- @(zz a) @(zz b))))

  (doc mul "multiplies two matrices.")
  (defn mul [a b]
    (init
      (* @(xx a) @(xx b)) (* @(xy a) @(xy b)) (* @(xz a) @(xz b))
      (* @(yx a) @(yx b)) (* @(yy a) @(yy b)) (* @(yz a) @(yz b))
      (* @(zx a) @(zx b)) (* @(zy a) @(zy b)) (* @(zz a) @(zz b))))

  (doc multrans "multiplies two matrices<sup>T</sup>.")
  (defn multrans [a b]
    (init
      (+ (* @(xx a) @(xx b)) (+ (* @(xy a) @(yx b)) (* @(xz a) @(zx b))))
      (+ (* @(xx a) @(xy b)) (+ (* @(xy a) @(yy b)) (* @(xz a) @(zy b))))
      (+ (* @(xx a) @(xz b)) (+ (* @(xy a) @(yz b)) (* @(xz a) @(zz b))))
      (+ (* @(yx a) @(xx b)) (+ (* @(yy a) @(yx b)) (* @(yz a) @(zx b))))
      (+ (* @(yx a) @(xy b)) (+ (* @(yy a) @(yy b)) (* @(yz a) @(zy b))))
      (+ (* @(yx a) @(xz b)) (+ (* @(yy a) @(yz b)) (* @(yz a) @(zz b))))
      (+ (* @(zx a) @(xx b)) (+ (* @(zy a) @(yx b)) (* @(zz a) @(zx b))))
      (+ (* @(zx a) @(xy b)) (+ (* @(zy a) @(yy b)) (* @(zz a) @(zy b))))
      (+ (* @(zx a) @(xz b)) (+ (* @(zy a) @(yz b)) (* @(zz a) @(zz b))))))

  (doc scale "scales a matrix `m` by a constant factor `k`, element-wise.")
  (defn scale [m k]
    (init
      (* @(xx m) k) (* @(xy m) k) (* @(xz m) k)
      (* @(yx m) k) (* @(yy m) k) (* @(yz m) k)
      (* @(zx m) k) (* @(zy m) k) (* @(zz m) k)))

  (doc col "gets a column—as a `Vector3`—from a matrix `m` by index. Valid
values are `0` to `2`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn col [m i]
    (case i
      0 (Maybe.Just (Vector3.init @(xx m) @(yx m) @(zx m)))
      1 (Maybe.Just (Vector3.init @(xy m) @(yy m) @(zy m)))
      2 (Maybe.Just (Vector3.init @(xz m) @(yz m) @(zz m)))
      (Maybe.Nothing)))

  (doc row "gets a row—as a `Vector3`—from a matrix `m` by index. Valid values
are `0` to `2`.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn row [m i]
    (case i
      0 (Maybe.Just (Vector3.init @(xx m) @(xy m) @(xz m)))
      1 (Maybe.Just (Vector3.init @(yx m) @(yy m) @(yz m)))
      2 (Maybe.Just (Vector3.init @(zx m) @(zy m) @(zz m)))
      (Maybe.Nothing)))

  (doc diag "gets the diagonal of a matrix `m` as a `Vector3`.")
  (defn diag [m]
    (Vector3.init @(xx m) @(yy m) @(zz m)))

  (doc nth "gets an element in the matrix `m` by the row and column indices `i`
and `j`. Valid values are `0` to `2` for each.

Returns `Maybe.Nothing` if an invalid index is passed.")
  (defn nth [m i j]
    (case (+ (* 3 i) j)
      0 @(xx m)
      1 @(xy m)
      2 @(xz m)
      3 @(yx m)
      4 @(yy m)
      5 @(yz m)
      6 @(zx m)
      7 @(zy m)
      8 @(zz m)))

  (doc apply "applies a transformation matrix `m` to a `Vector3` `v`.")
  (defn apply [m v]
    (let [x @(Vector3.x v)
          y @(Vector3.y v)
          z @(Vector3.z v)]
      (Vector3.init
        (+ (* @(xx m) x) (+ (* @(xy m) y) (* @(xz m) z)))
        (+ (* @(yx m) x) (+ (* @(yy m) y) (* @(yz m) z)))
        (+ (* @(zx m) x) (+ (* @(zy m) y) (* @(zz m) z))))))

  (doc apply-left "applies a transformation matrix `m` to a `Vector3` `v`,
applied on the left.")
  (defn apply-left [m v]
    (let [x @(Vector3.x v)
          y @(Vector3.y v)
          z @(Vector3.z v)]
      (Vector3.init
        (+ (* @(xx m) x) (+ (* @(yx m) y) (* @(zx m) z)))
        (+ (* @(xy m) x) (+ (* @(yy m) y) (* @(zy m) z)))
        (+ (* @(xz m) x) (+ (* @(yz m) y) (* @(zz m) z))))))

  (doc transform-point "transforms a `Vector2` representing a point by a matrix
`m`.")
  (defn transform-point [a v]
    (let [x @(Vector2.x v)
          y @(Vector2.y v)]
      (Vector2.init
        (+ (* @(xx m) x) (+ (* @(yx m) y) @(zx m)))
        (+ (* @(xy m) x) (+ (* @(yy m) y) @(zy m) z)))))

  (doc = "checks for matrix equality (by checking all members).")
  (defn = [a b]
    (and*
      (= (xx a) (xx b)) (= (xy a) (xy b)) (= (xz a) (xz b))
      (= (yx a) (yx b)) (= (yy a) (yy b)) (= (yz a) (yz b))
      (= (zx a) (zx b)) (= (zy a) (zy b)) (= (zz a) (zz b))))
)
