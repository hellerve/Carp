(system-include "carp_double.h")

(doc Double "is the default floating point number type.")
(defmodule Double
  (doc pi "the mathematical constant Ï€ (3.141592653589793).")
  (def pi 3.141592653589793)
  (implements pi Double.pi)
  (doc e "the mathematical constant e (2.718281828459045).")
  (def e 2.718281828459045)
  (doc MAX "the maximum value a Double can hold.")
  (register MAX Double "CARP_DBL_MAX")
  (implements MAX MAX)
  (doc = "returns true if `a` equals `b`.")
  (register = (Fn [Double Double] Bool))
  (doc < "returns true if `a` is less than `b`.")
  (register < (Fn [Double Double] Bool))
  (doc > "returns true if `a` is greater than `b`.")
  (register > (Fn [Double Double] Bool))
  (doc neg "negates a Double.")
  (register neg (Fn [Double] Double))
  (doc + "adds two doubles.")
  (register + (Fn [Double Double] Double))
  (doc - "subtracts `b` from `a`.")
  (register - (Fn [Double Double] Double))
  (doc * "multiplies two doubles.")
  (register * (Fn [Double Double] Double))
  (doc / "divides `a` by `b`.")
  (register / (Fn [Double Double] Double))
  (doc to-int "converts a Double to an Int by truncating toward zero.")
  (register to-int (Fn [Double] Int))
  (doc from-int "converts an Int to a Double.")
  (register from-int (Fn [Int] Double))
  (doc to-float "converts a Double to a Float (may lose precision).")
  (register to-float (Fn [Double] Float))
  (doc from-float "converts a Float to a Double.")
  (register from-float (Fn [Float] Double))
  (doc to-long "converts a Double to a Long by truncating toward zero.")
  (register to-long (Fn [Double] Long))
  (doc from-long "converts a Long to a Double.")
  (register from-long (Fn [Long] Double))
  (doc to-uint64 "converts a Double to a Uint64 by truncating toward zero.")
  (register to-uint64 (Fn [Double] Uint64))
  (doc from-uint64 "converts a Uint64 to a Double.")
  (register from-uint64 (Fn [Uint64] Double))
  (doc to-bytes "returns the raw bit representation of a Double as a Long.")
  (register to-bytes (Fn [Double] Long))
  (doc copy "copies a Double.")
  (register copy (Fn [(Ref Double)] Double))

  (implements + Double.+)
  (implements - Double.-)
  (implements * Double.*)
  (implements / Double./)
  (implements < Double.<)
  (implements > Double.>)
  (implements = Double.=)
  (implements copy Double.copy)
  (implements neg Double.neg)
  (implements to-int Double.to-int)
  (implements from-int Double.from-int)

  (doc abs "returns the absolute value of `a`.")
  (register abs (Fn [Double] Double))
  (doc acos "returns the arc cosine of `a` in radians.")
  (register acos (Fn [Double] Double))
  (doc asin "returns the arc sine of `a` in radians.")
  (register asin (Fn [Double] Double))
  (doc atan "returns the arc tangent of `a` in radians.")
  (register atan (Fn [Double] Double))
  (doc atan2 "returns the arc tangent of `y`/`x`, using the signs of both to determine the quadrant.")
  (register atan2 (Fn [Double Double] Double))
  (doc ceil "rounds `a` up to the nearest integer.")
  (register ceil (Fn [Double] Double))
  (doc cos "returns the cosine of `a` (in radians).")
  (register cos (Fn [Double] Double))
  (doc cosh "returns the hyperbolic cosine of `a`.")
  (register cosh (Fn [Double] Double))
  (doc exp "returns e raised to the power of `a`.")
  (register exp (Fn [Double] Double))
  (doc floor "rounds `a` down to the nearest integer.")
  (register floor (Fn [Double] Double))
  (doc frexp "splits `a` into a normalized fraction and an exponent, storing the exponent in `exp`.")
  (register frexp (Fn [Double (Ref Int)] Double))
  (doc ldexp "returns `a` multiplied by 2 raised to the power of `exp`.")
  (register ldexp (Fn [Double Int] Double))
  (doc log "returns the natural logarithm of `a`.")
  (register log (Fn [Double] Double))
  (doc log10 "returns the base-10 logarithm of `a`.")
  (register log10 (Fn [Double] Double))
  (doc mod "returns the floating-point remainder of dividing `a` by `b`.")
  (register mod (Fn [Double Double] Double))
  (doc modf "splits `a` into integer and fractional parts, storing the integer part in `int-part`.")
  (register modf (Fn [Double (Ref Double)] Double))
  (doc pow "returns `a` raised to the power of `b`.")
  (register pow (Fn [Double Double] Double))
  (doc sin "returns the sine of `a` (in radians).")
  (register sin (Fn [Double] Double))
  (doc sinh "returns the hyperbolic sine of `a`.")
  (register sinh (Fn [Double] Double))
  (doc sqrt "returns the square root of `a`.")
  (register sqrt (Fn [Double] Double))
  (doc tan "returns the tangent of `a` (in radians).")
  (register tan (Fn [Double] Double))
  (doc tanh "returns the hyperbolic tangent of `a`.")
  (register tanh (Fn [Double] Double))

  (implements abs Double.abs)
  (implements acos Double.acos)
  (implements asin Double.asin)
  (implements atan Double.atan)
  (implements atan2 Double.atan2)
  (implements ceil Double.ceil)
  (implements cos Double.cos)
  (implements cosh Double.cosh)
  (implements exp Double.exp)
  (implements floor Double.floor)
  (implements frexp Double.frexp)
  (implements ldexp Double.ldexp)
  (implements log Double.log)
  (implements log10 Double.log10)
  (implements mod Double.mod)
  (implements modf Double.modf)
  (implements pow Double.pow)
  (implements sin Double.sin)
  (implements sinh Double.sinh)
  (implements sqrt Double.sqrt)
  (implements tan Double.tan)
  (implements tanh Double.tanh)

  (doc approx "checks whether `x` and `y` are approximately equal.

The margin of error is `0.00001`.")
  (defn approx [x y]
    (Generics.approx x y))

  (doc zero "returns the value `0.0`.")
  (defn zero []
    0.0)
  (implements zero Double.zero)

  (doc inc "increments a Double by 1.0.")
  (defn inc [x]
    (+ 1.0 x))
  (implements inc Double.inc)

  (doc dec "decrements a Double by 1.0.")
  (defn dec [x]
    (- x 1.0))
  (implements dec Double.dec)

  (doc add-ref "adds two Double values passed as references.")
  (defn add-ref [x y]
    (Double.+ @x @y))
  (implements add-ref Double.add-ref)
)

(defmodule DoubleRef
  (defn = [a b]
    (Double.= @a @b))
  (implements = DoubleRef.=)

  (defn < [a b]
    (Double.< @a @b))
  (implements < DoubleRef.<)

  (defn > [a b]
    (Double.> @a @b))
  (implements > DoubleRef.>)
)
